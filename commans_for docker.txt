Steps:
1. Create a project on github and pull to our local machine
2. Create the following files and a folder, then populate them with the text first
        > Dockerfile
        > requirements.txt
        > .dockerignore
        > app

3. Install docker and docker-compose in our local machine if not already installed. (this is one time action)
        $ sudo apt install docker.io
        $ sudo apt install docker-compose

4. Execute the build command
        $ sudo docker build .  // here . is for current directory

5. Create docker-compose.yml and populate with and then build a docker-compose image
        $ sudo docker-compose build

6. Extention download on VSCode
        > docker  (for automated docker command)
        > Flake8  (for linting)
        > Pylance


7. Now some work with flake8.
        > create requirements.dev.txt file and populate with code I made.
        > update docker-compose.yml file by adding new lines in no (7,12, 16-18)
        > and finally build the docker image again
                $ sudo docker-compose build

        > create requirements.dev.txt file and populate with code
        > then run the flake8 running command again
                $ sudo docker-compose run --rm app sh -c "flake8"  // this command is not working on my machine

8. Create a django project in the docker container
        $ sudo docker-compose run --rm app sh -c "django-admin startproject app ."  // here . is to avoid creating the sub-directory

9. Run django project within the docker container
        $ sudo docker-composer up

10. Create github actions - steps ->
        > create checks.yml within (root direction) .github/workflows/checks.yml
        > then populate the checks.yml file

11. Adding Database services to Docker
        > update docker-compose.yml file with line 15 to 33 and then
        $ sudo docker-compose up  // to stest if everything added correctly
        finally Ctrl+C and
                $ sudo docker-compose down  // to completely stop the container services

12. Connect Database with django using docker
        > add the following in order and sequence as in Dockerfile
                apk add --update --no-cache postgresql-client && \
                apk add --update --no-cache --virtual .tmp-build-deps \
                build-base postgresql-dev musl-dev && \

                apk del .tmp-build-deps && \

        > update the requirements.txt file with
                psycopg2>=2.8.6,<2.9   // it is a adapter to connect database with django

        *** finally build the docker-compose and push to git
                $ sudo docker-compose build

        > update the DATABASES array of settings.py file with postgresql engine

        > add wait_for_db with the following steps
                > create new app called core
                        $ sudo docker-compose run --rm app sh -c "python manage.py startapp core"
                        > add this app to settings.py > INSTALLED_APPS
                > 'core' app structured with file and folders that contains
                        > test files &
                        > wait_for_db.py file
                        *** copy them all
                > after having done the test files, we can execute the following to test
                        $ sudo docker-compose run --rm app sh -c "python manage.py test"  // for testing the whole project
                        $ sudo docker-compose run --rm app sh -c "python manage.py <file_name>"  // for a single file testing
                > and for flake8 as well
                        $ sudo docker-compose run --rm app sh -c "python manage.py test && flake8"

13. Create custom User_model (DEEP DIVE)
        > let's create a test class first with the core > tests > test_models.py before creating our custom User_model and
          run test command to check if our test model is correctly written.

        > update models.py (app/core) file with 2 classes -
                > UserManager &&
                > User
        > update settings.py file by adding the following to the last -
                > AUTH_USER_MODEL = 'core.User'
        > now it's time to makemigrations our newly created model in the core directory
                $ sudo docker-compose run --rm app sh -c "python manage.py makemigrations"

                *** core/migrations/0001_initial.py file will be automatically created.
        > finally execute the migrate command -
                 $ sudo docker-compose run --rm app sh -c "python manage.py wait_for_db && python manage.py migrate"

                 *** IF ANY ISSUE FOUND IN THE CONSOLE LIKE 'django.db.migrations.exceptions.InconsistentMigrationHistory'
                     then check if any existing Volume in the database -
                        $ sudo docker volume ls  // if found something then delete it
                        $ sudo docker-compose down  // stop the running container first then
                        $ sudo docker volume rm <Volume_name>  // this command will remove the volume
                        NOW EXECUTE THE MIGRATE COMMAND AGAIN
                        $ sudo docker-compose run --rm app sh -c "python manage.py wait_for_db && python manage.py migrate" // THIS COMMAND SHOULD MIGRATE THE DATABASE SUCCESSFULLY
        > and again finally we are gonna test again if everyting perfect
                $ sudo docker-compose run --rm app sh -c "python manage.py test"

                *** if any error found, just fix them and test again until successful.

        > NORMALIZE USER MODEL // VIDEO (09:005)
                > first write some test code in the test_models.py (i.e. def => test_new_user_email_normalized)
                > then update models.py > class UserManager(BaseUserManager) > line 17 >
                        > self.normalize_email(email)

                > now execute test command to check if everything ok

        > Raise ValueError if email address not provided // VIDEO (09:006)
                > first write a test in test_models.py (i.e. def => test_new_user_without_email_raises_error)
                > then update models.py > class UserManager(BaseUserManager) > above line 17 >
                        > if not email:
                                raise ValueError('User must provide an email address')

                > now test them if it's working fine.

        > CREATE A SUPER_USER CLASS AND TEST METHOD
                > first write a test in test_models.py (i.e. def => test_create_superuser)
                > then write a new def (i.e. create_superuser())

                > now test them if it's working fine.

        > CREATE SUPERUSER AND LOG INTO THE SERVER
                > sudo docker-compose run --rm app sh -c "python manage.py createsuperuser"
                        > add email and credentials
                > visit > http://127.0.0.1:8000/admin/  and log in with credentials that we have just created

